<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="robots" content="noindex,nofollow" />
  <title>connection</title>

  <style>
    * {
      box-sizing: border-box;
    }
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
    }
    body {
      background: #000;
      color: #f5f5ff;
      font-family: -apple-system, system-ui, "Apple SD Gothic Neo",
        "Noto Sans KR", sans-serif;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
      overflow-y: auto;
      padding: 2px 8px 8px;
    }

    /* 특정 노드에서 탑바 숨기기 */
.top-bar.topbar-hidden {
  opacity: 0;
  visibility: hidden;
}

  /* 404  효과 없음 */
.error-corner {
  position: fixed;
  top: 14px;
  left: 14px;
  margin: 0;
  padding: 0;
  max-width: calc(100vw - 28px);

  text-align: left !important;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  font-size: 16px !important;
  line-height: 1.35;

  color: #f5f5ff;
  text-shadow: none !important;
}

    /* 불안하게 깜빡이는 텍스트 */
.flicker {
  animation: flicker 1.4s infinite;
}

@keyframes flicker {
  0%   { opacity: 1;   text-shadow: 0 0 8px rgba(255,255,255,0.8); }
  10%  { opacity: 0.3; text-shadow: 0 0 2px rgba(255,255,255,0.4); }
  20%  { opacity: 0.8; }
  35%  { opacity: 0.2; }
  50%  { opacity: 1;   text-shadow: 0 0 14px rgba(255,255,255,1); }
  70%  { opacity: 0.4; }
  85%  { opacity: 0.9; }
  100% { opacity: 1; }
}

    /* 글리치 텍스트 효과 */
.glitch {
  animation: glitch 0.6s infinite;
}

@keyframes glitch {
  0% {
    transform: translate(0, 0);
    text-shadow:
      1px 0 rgba(255, 0, 255, 0.8),
      -1px -1px rgba(0, 255, 255, 0.8);
  }
  20% {
    transform: translate(-1px, 1px);
    text-shadow:
      -2px 0 rgba(255, 0, 255, 0.6),
      2px 2px rgba(0, 255, 255, 0.6);
  }
  40% {
    transform: translate(1px, -1px);
    text-shadow:
      2px -1px rgba(255, 0, 255, 0.9),
      -2px 1px rgba(0, 255, 255, 0.9);
  }
  60% {
    transform: translate(0, 0);
    text-shadow:
      -1px 1px rgba(255, 0, 255, 0.5),
      1px -1px rgba(0, 255, 255, 0.5);
  }
  80% {
    transform: translate(1px, 0);
    text-shadow:
      2px 0 rgba(255, 0, 255, 0.7),
      -2px 0 rgba(0, 255, 255, 0.7);
  }
  100% {
    transform: translate(0, 0);
    text-shadow:
      0 0 4px rgba(255, 255, 255, 0.8);
  }
}

    /* 압박감 텍스트 – 자간이 좁아졌다 넓어졌다 */
.pressure-text {
  animation: pressureText 1.4s ease-in-out infinite;
}

@keyframes pressureText {
  0% {
    letter-spacing: 0em;
  }
  40% {
    letter-spacing: -0.08em;   /* 글자들이 서로 가까워짐 */
  }
  70% {
    letter-spacing: -0.03em;
  }
  100% {
    letter-spacing: 0em;
  }
}

    /* 인트로 화면 */
    .intro {
      position: fixed;
      inset: 0;
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }
    .intro-text {
      font-size: 25px;
      letter-spacing: 0.3em;
      color: #f5f5ff;
      text-shadow:
        0 0 8px rgba(255, 255, 255, 0.9),
        0 0 22px rgba(54, 84, 255, 0.9);
      animation: introPulse 1.2s ease-in-out infinite alternate;
    }
    @keyframes introPulse {
      from { opacity: 0.4; }
      to   { opacity: 1; }
    }
    .intro.fade-out {
      animation: introFadeOut 0.8s ease forwards;
    }
    @keyframes introFadeOut {
      to {
        opacity: 0;
        visibility: hidden;
      }
    }

    /* 본 화면 컨테이너 */
    .app {
      width: 100%;
      max-width: 900px;
      margin: 8px auto 16px;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      opacity: 0;
      pointer-events: none;
    }
    .app.visible {
      opacity: 1;
      pointer-events: auto;
      transition: opacity 0.6s ease;
    }

    /* 프레임 */
    .frame {
      position: relative;
      width: 100%;
      max-width: 900px;
      margin: 0 auto;
    }

    /* HUD */
    .top-bar {
      width: 100%;
      height: 87px;
      background-image: url("top-bar.png");
      background-repeat: no-repeat;
      background-position: center top;
      background-size: 100% auto;
      pointer-events: none;
    }

    .content {
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 4px;
      transform-origin: center;
      margin-top: 64px;
      padding: 0 8px;
    }

    /* Q 라벨 */
    .q-label {
      font-size: 30px;
      color: #ffffff;
      text-align: center;
      text-shadow:
        0 0 6px rgba(255, 255, 255, 0.9),
        0 0 18px rgba(255, 255, 255, 0.9);
      margin-bottom: 2px;  /* Q1과 질문을 바짝 */
      display: none;
    }

    /* 질문/반응 텍스트 */
    .q-text {
      font-size: 22px;
      line-height: 1.6;
      white-space: pre-wrap;
      text-align: center;
      margin-top: 0;       /* 위 여백 없애기 */
    }

    /* 기본 네온 글로우 */
    .glow {
      text-shadow:
        0 0 6px rgba(255, 255, 255, 0.9),
        0 0 18px rgba(255, 255, 255, 0.9);
    }

    /* 빨간 네온 텍스트 */
    .red {
      color: #ff3058;
      text-shadow:
        0 0 6px rgba(255, 119, 155, 0.9),
        0 0 24px rgba(255, 40, 72, 0.95);
    }

    /* 파란 네온 텍스트 */
    .blue {
      color: #3654ff;
      text-shadow:
        0 0 6px rgba(54, 84, 255, 0.9),
        0 0 18px rgba(54, 84, 255, 0.9);
    }

    /* 빨간 박스 강조 */
    .box-red {
      display: inline-block;
      padding: 16px 24px;
      border-radius: 14px;
      border: 1px solid rgba(255, 48, 88, 0.8);
      background: rgba(255, 48, 88, 0.08);
      margin-top: 24px;
    }

    .emph {
      font-weight: 700;
    }

    /* 선택지 컨테이너 */
    .choices {
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-top: 60px;
    }

    /* 버튼 */
    .choice-btn {
      position: relative;
      display: flex;
      align-items: center;
      width: 100%;
      max-width: 700px;

      aspect-ratio: 3 / 1;
      height: auto;

      margin: 0 auto;
      border: none;
      border-radius: 0;
      padding: 4px 64px;
      text-align: left;
      font-size: 21px;
      cursor: pointer;
      color: #f5f6ff;
      background-color: transparent;
      background-image: url("frame.png");
      background-position: center;
      background-size: 100% 100%;
      background-repeat: no-repeat;
      outline: none;
      overflow: hidden;
      transform-origin: center;
    }

    /* ───── 불안한(위험한) 버튼 연출 ───── */
.choice-btn.ominous-btn {
  /* 기본 버튼 스타일 그대로 두고, 위에 덮어씌우는 효과만 추가 */
  animation: ominousPulse 1.7s ease-in-out infinite;
}

/* 버튼 위에 지나가는 붉은 스캔 라인 */
.choice-btn.ominous-btn::after {
  content: "";
  position: absolute;
  inset: 0;
  background: linear-gradient(
    to bottom,
    rgba(255, 70, 100, 0) 0%,
    rgba(255, 70, 100, 0.35) 50%,
    rgba(255, 70, 100, 0) 100%
  );
  mix-blend-mode: screen;
  opacity: 0;
  transform: translateY(-100%);
  pointer-events: none;
  animation: ominousScan 2.6s linear infinite;
}

/* 전체적으로 숨이 가빠지는 느낌 */
@keyframes ominousPulse {
  0% {
    transform: scale(1);
    filter: brightness(1) saturate(1);
    box-shadow: 0 0 0 rgba(255, 40, 72, 0);
  }
  40% {
    transform: scale(1.02);
    filter: brightness(1.05) saturate(1.2);
    box-shadow: 0 0 14px rgba(255, 40, 72, 0.55);
  }
  70% {
    transform: scale(0.99);
    filter: brightness(0.95) saturate(0.9);
    box-shadow: 0 0 4px rgba(255, 40, 72, 0.25);
  }
  100% {
    transform: scale(1);
    filter: brightness(1) saturate(1);
    box-shadow: 0 0 0 rgba(255, 40, 72, 0);
  }
}

/* 위에서 아래로 슬쩍 지나가는 불길한 빛 */
@keyframes ominousScan {
  0% {
    opacity: 0;
    transform: translateY(-120%);
  }
  20% {
    opacity: 1;
  }
  60% {
    opacity: 0.4;
    transform: translateY(40%);
  }
  100% {
    opacity: 0;
    transform: translateY(140%);
  }
}

    .choice-btn span {
      position: relative;
      z-index: 1;
      text-shadow:
        0 0 4px rgba(0, 0, 0, 0.9),
        0 0 12px rgba(0, 0, 0, 0.8);
      white-space: normal;
      word-break: keep-all;
      overflow: hidden;
      text-overflow: clip;

      margin-left: 30px;  /* 더 오른쪽 */
      margin-top: 6px;    /* 살짝 아래 */
    }

    .choice-btn::before {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(
        circle at 0 0,
        rgba(255, 255, 255, 0.18),
        transparent 55%
      );
      opacity: 0;
      transition: opacity 0.18s ease;
    }

    .choice-btn:hover::before {
      opacity: 0.4;
    }

    .choice-btn:active {
      transform: scale(0.97);
    }

    .choice-btn.red span {
      color: #ffdae2;
    }

    /* 질문 / 버튼 등장 애니메이션 */
    .question-enter {
      animation: questionIn 0.6s ease-out forwards;
    }
    @keyframes questionIn {
      from {
        opacity: 0;
        transform: scale(0.96);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    .choices-enter .choice-btn {
      opacity: 0;
      transform: translateY(10px) scale(0.96);
      animation: btnPop 0.28s ease-out forwards;
    }
    @keyframes btnPop {
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    .choices-hide {
      animation: choicesFadeOut 0.35s ease forwards;
    }
    @keyframes choicesFadeOut {
      to {
        opacity: 0;
        transform: translateY(6px);
      }
    }

    .fade-out {
      animation: textFadeOut 1s ease forwards;
    }
    @keyframes textFadeOut {
      to { opacity: 0; }
    }

    /* 지진 효과 */
    .shake {
      animation: shake 0.35s ease-in-out infinite;
    }
    @keyframes shake {
      0%   { transform: translate(0px, 0px); }
      25%  { transform: translate(-1px, 1px); }
      50%  { transform: translate(1px, -1px); }
      75%  { transform: translate(-1px, -1px); }
      100% { transform: translate(1px, 1px); }
    }

    /* 화면 암전 */
    .screen-dark {
      animation: fadeToBlack 2.2s ease forwards;
    }
    @keyframes fadeToBlack {
      to {
        background: #000;
        color: #aeb0ff;
      }
    }

    .hard-black {
      background: #000 !important;
      color: #000 !important;
      box-shadow: none !important;
      border-color: #000 !important;
    }

    /* 엔딩 메시지 오버레이 */
    .msg-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.82);
      display: flex;
      justify-content: center;
      align-items: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
      z-index: 30;
    }
    .msg-overlay.show {
      opacity: 1;
      pointer-events: auto;
    }
    .msg-window {
      width: 90%;
      max-width: 420px;
      background: #111317;
      border-radius: 18px;
      box-shadow: 0 18px 45px rgba(0, 0, 0, 0.9);
      overflow: hidden;
      border: 1px solid rgba(54, 84, 255, 0.8);
      color: #f7f7ff;
      font-size: 14px;
    }
    .msg-header {
      padding: 10px 16px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      font-weight: 600;
      letter-spacing: 0.08em;
      font-size: 12px;
      text-transform: uppercase;
      color: #aab3ff;
    }
    .msg-body {
      padding: 18px 16px 12px;
      line-height: 1.7;
      white-space: pre-wrap;
    }
    .msg-close {
      width: 100%;
      border: none;
      padding: 10px 0 12px;
      background: #23263a;
      color: #f5f5ff;
      font-size: 13px;
      cursor: pointer;
    }
    .msg-close:hover {
      background: #2f3550;
    }

    /* ───────── 모바일 전용 설정 ───────── */
    @media (max-width: 480px) {

      body {
        padding: 0 6px 8px;
      }

      .top-bar {
        height: 83px;
        background-size: 100% auto;
        background-position: center top;
      }

      .content {
        margin-top: 75px;
        padding: 0 4px;
      }

      .q-label {
        font-size: 24px;
        margin-bottom: 4px;
      }

      .q-text {
        font-size: 20px;
        margin-top: 0;
      }

      .choices {
        gap: 3px;
        margin-top: 80px;
      }

      .choice-btn {
        max-width: 100%;
        aspect-ratio: 4.3 / 1;
        height: auto;
        padding: 4px 32px;
        font-size: 15px;
        background-size: 100% 100%;
      }

      .choice-btn span {
        margin-left: 22px;
        position: relative;
        top: 1.5px;
        line-height: 1.3;
      }
    }
  </style>
</head>

<body>
  <audio id="sfxIntro" src="sfx-intro.mp3" preload="auto"></audio>
  <audio id="bgm" src="bgm.mp3" preload="auto" loop></audio>
  <audio id="voice" src="voice.mp3" preload="auto"></audio>
<audio id="sfxHit" src="sfx-hit.mp3" preload="auto"></audio>
  
  <div class="intro" id="intro">
    <div class="intro-text">연결합니다</div>
  </div>

  <!-- 질문 화면 -->
  <div class="app" id="app">
    <div class="frame" id="frame">
      <div class="top-bar"></div>

      <div class="content" id="content">
        <div class="q-label glow" id="qLabel"></div>
        <div class="q-text glow" id="qText"></div>
        <div class="choices" id="choices"></div>
      </div>
    </div>
  </div>

  <!-- 엔딩용 메시지 오버레이 -->
  <div class="msg-overlay" id="msgOverlay">
    <div class="msg-window">
      <div class="msg-header">SYSTEM MESSAGE</div>
      <div class="msg-body" id="msgBody">
에러 발생!&#10;Room "11번"과의 연결이 끊겼습니다.
      </div>
      <button class="msg-close" id="msgClose">확인</button>
    </div>
  </div>

  <script>
       // 오디오
    const bgmEl    = document.getElementById("bgm");
    const voiceEl  = document.getElementById("voice");
    const sfxHitEl = document.getElementById("sfxHit");
    const sfxIntroEl = document.getElementById("sfxIntro");

    function playIntroSfx() {
  if (!sfxIntroEl) return;
  sfxIntroEl.volume = 0.9;
  sfxIntroEl.currentTime = 0;
  sfxIntroEl.play().catch(() => {
    const resume = () => {
      sfxIntroEl.currentTime = 0;
      sfxIntroEl.play().catch(() => {});
      document.removeEventListener("click", resume);
      document.removeEventListener("touchstart", resume);
    };
    document.addEventListener("click", resume, { once: true });
    document.addEventListener("touchstart", resume, { once: true });
  });
}
    
    function tryStartBgm() {
      if (!bgmEl) return;
     // bgmEl.volume = 0.7;
      bgmEl.play().catch(() => {
        const resume = () => {
          bgmEl.play().catch(() => {});
          document.removeEventListener("click", resume);
          document.removeEventListener("touchstart", resume);
        };
        document.addEventListener("click", resume);
        document.addEventListener("touchstart", resume);
      });
    }

    // 브금 “확” 꺼버리기
    function hardStopBgm() {
      if (!bgmEl) return;
      bgmEl.pause();
      bgmEl.currentTime = 0;  // 처음으로 되감기
    }

    // 브금 서서히 줄이기 (페이드 아웃)
    function fadeOutBgm(durationMs = 1500) {
      if (!bgmEl) return;

      const startVolume = bgmEl.volume ?? 0.7;
      const steps = 20;
      const stepTime = durationMs / steps;
      let currentStep = 0;

      const fadeTimer = setInterval(() => {
        currentStep++;
        const t = currentStep / steps;
        const v = startVolume * (1 - t);
        bgmEl.volume = Math.max(0, v);

        if (currentStep >= steps) {
          clearInterval(fadeTimer);
          bgmEl.pause();
          bgmEl.currentTime = 0;
          bgmEl.volume = startVolume; // 다음에 다시 켤 때를 위해 원상복귀
        }
      }, stepTime);
    }

    // 효과음 한 번 재생
    function playHitSfx() {
      if (!sfxHitEl) return;
      sfxHitEl.currentTime = 0;
      sfxHitEl.play().catch(() => {});
    }

    // 죽어 있던 브금 다시 켜기
    function resumeBgm(volume = 0.7) {
      if (!bgmEl) return;
      bgmEl.volume = volume;
      bgmEl.play().catch(() => {});
    }

  function fadeInBgm(durationMs = 1500, targetVolume = 0.7) {
  if (!bgmEl) return;

  bgmEl.play().catch(() => {});

  const steps = 20;
  const stepTime = durationMs / steps;
  const startVolume = bgmEl.volume ?? 0;
  let currentStep = 0;

  const fadeTimer = setInterval(() => {
    currentStep++;
    const t = currentStep / steps;
    const v = startVolume + (targetVolume - startVolume) * t;
    bgmEl.volume = Math.min(targetVolume, Math.max(0, v));

    if (currentStep >= steps) {
      clearInterval(fadeTimer);
      bgmEl.volume = targetVolume;
    }
  }, stepTime);
}
    
    const BUTTON_DELAY_MS = 1200;

    // 스토리 노드
  const NODES = {
  q0: {
    id: "q0",
    label: "",
    type: "typewriter",
    typeSpeedMs: 195,
    fontSize: 23,
    text: "[pause][pause]...들리십니까?",
    delayMs: 2000,
    options: [
      { label: "네", next: "q0_success" },
      { label: "아니오", next: "q0_regret" }
    ]
  },

  q0_success: {
    id: "q0_success",
    label: "",
    type: "typewriter",
    typeSpeedMs: 190,
    fontSize: 23,
    text: "[pause]성공적으로\n[pause]연결 되었습니다.",
    autoNext: "q0_start",
    autoDelayMs: 2000
  },

  q0_regret: {
    id: "q0_regret",
    label: "",
    blue: true,
    type: "typewriter",
    typeSpeedMs: 180,
    fontSize: 23,
    text: "유감이군요.",
    autoNext: "q0_start",
    autoDelayMs: 2000
  },

  q0_start: {
    id: "q0_start",
    label: "",
    type: "typewriter",
    typeSpeedMs: 185,
    fontSize: 22,
    text: "그러면...[pause]\n바로 질문을 시작하도록 할까요.",
    autoNext: "q1",
    autoDelayMs: 2000
  },

  q1: {
    id: "q1",
    label: "Q1",
    type: "typewriter",
    typeSpeedMs: 170,
    fontSize: 23,
    text: "[pause]당신은 누구입니까?",
    delayMs: 2000,
    options: [
      { label: "...", next: "q1_r1" },
      { label: "답하지 않는다.", next: "q1_r2" }
    ]
  },

  q1_r1: {
    id: "q1_r1",
    label: "",
    type: "typewriter",
    typeSpeedMs: 180,
    fontSize: 23,
    text: "[pause]...머뭇거리고 계시는군요.",
    autoNext: "q2",
    autoDelayMs: 2000
  },

  q1_r2: {
    id: "q1_r2",
    label: "",
    type: "typewriter",
    typeSpeedMs: 180,
    fontSize: 23,
    text: "[pause]...대답이 없으시군요.",
    autoNext: "q2",
    autoDelayMs: 2000
  },

  q2: {
    id: "q2",
    label: "Q2",
    type: "typewriter",
    typeSpeedMs: 170,
    fontSize: 22,
    text: "지금 [pause]말을 걸고 있는 존재가\n누구인지 알고 있습니까?",
    delayMs: 2000,
    options: [
      { label: "알고 있습니다.", next: "q2_1" },
      { label: "...잘 모르겠습니다.", next: "q2_unknown" }
    ]
  },

  q2_unknown: {
    id: "q2_unknown",
    label: "",
    type: "typewriter",
    typeSpeedMs: 180,
    fontSize: 23,
    text: "[pause]좋습니다.",
    autoNext: "q3",
    autoDelayMs: 2000
  },

  q2_1: {
    id: "q2_1",
    label: "",
    red: true,
    type: "typewriter",
    typeSpeedMs: 250,
    fontSize: 24,
    text: "...[pause]확실합니까?",
    delayMs: 2000,
    options: [
      { label: "네, 저는 당신이 누군지 알아요.", next: "q2_2" },
      { label: "사실 잘 모르겠습니다.", next: "q3" },
      { label: "글쎄요...", next: "q3" }
    ]
  },

  q2_2: {
    id: "q2_2",
    label: "",
    red: true,
    type: "typewriter",
    typeSpeedMs: 65,
    fontSize: 21,
    boxRed: true,
    glitch: true,
    shake: true,
    text:
      "서 버  로 그  데 이 터 를  바 탕 으 로 \n당 신 의  기 억 정 상 여 부 를 \n재 점 검 합 니 다.",
    autoNext: "q2_2_cut",
    autoDelayMs: 4000
  },

  q2_2_cut: {
    id: "q2_2_cut",
    label: "",
    red: true,
    fontSize: 35,
    boxRed: true,
    text: "<점검 완료>",
    autoNext: "q3",
    autoDelayMs: 4000
  },

  q3: {
    id: "q3",
    label: "Q3",
    type: "typewriter",
    typeSpeedMs: 170,
    fontSize: 22,
    text: "당신에게는 소중한 누군가나\n가족이 있습니까?",
    delayMs: 2000,
    options: [
      { label: ".....", next: "q4" },
      { label: "답하지 않는다.", next: "q4" }
    ]
  },

  q4: {
    id: "q4",
    label: "Q4",
    fontSize: 20,
    text:
      "당신의 소중한 사람이 눈앞에서\n죽어가고 있을 때,\n살릴 수 있는 방법을 알게 된다면\n살리시겠습니까? 아니면 방관하시겠습니까?",
    delayMs: 2000,
    options: [
      { label: "어떻게든 살려낸다.", next: "q4_r1" },
      { label: "살리지 않는다.", next: "q4_r2" }, // Q5 감정으로 우회
      { label: "서서히 죽어가도록 내버려둔다.", next: "q4_r3", isThird: true }
    ]
  },

  q4_r1: {
    id: "q4_r1",
    label: "",
    type: "typewriter",
    typeSpeedMs: 210,
    fontSize: 23,
    text: ".[pause].[pause].[pause]\n그렇군요.[pause] 당신은 그렇군요.",
    autoNext: "q5",
    autoDelayMs: 4000
  },

  q4_r2: {
    id: "q4_r2",
    label: "",
    type: "typewriter",
    typeSpeedMs: 210,
    fontSize: 23,
    text: ".[pause].[pause].[pause]\n그렇군요.[pause]\n당신은 그렇군요.",
    autoNext: "q5_alt", // 감정 Q5
    autoDelayMs: 4000
  },

  q4_r3: {
    id: "q4_r3",
    label: "",
    red: true,
    fontSize: 24,
    text: "데이터에 이상이 감지되었습니다!",
    noEnterAnim: true,
    cornerText: true, 
    stopBgmHard: true,
    hideTopBar: true,
    autoNext: "q5",
    autoDelayMs: 4000
  },

  q5: {
    id: "q5",
    label: "Q5",
    fontSize: 20,
    text:
      "당신은 소중한 사람이 계속해서 죽어갈 때마다 \n다시 살려낼 것 입니까? \n아니면, 죽어가도록 내버려두겠습니까?",
    delayMs: 2000,
    startBgm: true,
    options: [
      {
        label: "소중한 사람을 잃고 싶지 않아요.\n어떻게든 끝까지 노력해서 살려낼 것 같아요.",
        next: "q6"
      },
      {
        label: "그냥...포기한 채로, 내버려둘 것 같아요.",
        next: "q6"
      },
      {
        label: "딱히 관심 없어요. 아무렇지도 않을 것 같아요.",
        next: "q6",
        isThird: true
      }
    ]
  },

  q5_alt: {
    id: "q5_alt",
    label: "Q5",
    fontSize: 20,
    text: "살리지 않기로 결정했습니다.\n당신은 어떤 느낌이 드십니까?",
    delayMs: 2000,
    options: [
      { label: "공포", next: "q6" },
      { label: "안도감", next: "q6" },
      { label: "죄책감", next: "q6" },
      { label: "통쾌함", next: "q6", isThird: true }
    ]
  },

  q6: {
    id: "q6",
    label: "Q6",
    fontSize: 21,
    text:
      "어떤 방식이든 가능하기만 하다면,\n삶을 끝없이 이어 붙일 수 있다고 생각하십니까?",
    delayMs: 2000,
    options: [
      { label: "...그럴 수는 없을거에요.", next: "q7" },
      {
        label: "네, 분명히요.\n언젠가는 그런 경험을 하게 될 날이 오기를 바라고 있어요.",
        next: "q7"
      },
      { label: "그런 거엔 관심이 없습니다.", next: "q7", isThird: true }
    ]
  },

  q7: {
    id: "q7",
    label: "Q7",
    fontSize: 22,
    text: "당신에게 있어, ‘죽음’이란 무엇입니까?",
    delayMs: 2000,
    options: [
      { label: " 단 하나의 종료 버튼이에요.", next: "q8" },
      { label: "모든 것의 종착점이자, 멋진 완결 페이지에요.", next: "q8" },
      { label: "생명이 기능을 정지하는 것이라고 생각해요.", next: "q8" },
      { label: "늘 두려워하는 거에요.", next: "q8", isThird: true }
    ]
  },

  q8: {
    id: "q8",
    label: "Q8",
    fontSize: 21,
    text:
      "몸이 없더라도,\n스스로 의식을 가진 개체에게\n‘생명’이라는 말을 사용할 수 있습니까?",
    delayMs: 2000,
    options: [
      { label: "네, 그럴 수 있다고 생각해요.", next: "q9" },
      { label: "아니요...그래도 그건 생명이라고 부르기 어렵습니다.", next: "q9" }
    ]
  },

  q9: {
    id: "q9",
    label: "Q9",
    fontSize: 23,
    text:
      "당신의 기억과 동기화된 작은 데이터 개체의\n생성여부를 확인해보시겠습니까?",
    delayMs: 2000,
    options: [
      { label: "좋아요!", next: "q9_1" },
      { label: "사양할게요..", next: "q9_no" }
    ],
    fadeOutBgmMs: 1200
  },

  q9_1: {
    id: "q9_1",
    label: "",
    type: "typewriter",
    typeSpeedMs: 173,
    fontSize: 20,
    text:
      "여기-[pause] 당신의 데이터 개체가\n이 곳을 벗어나기 위해,\n애원하며 많은 질문을 던져옵니다.[pause]\n이 개체를 삭제할 권리가 당신에게 있다고 생각하십니까?",
    delayMs: 2000,
    options: [
      { label: "네, 그건 제가 만든 개체이니까요.", next: "q9_interesting" },
      { label: "아니요, 온전히 제 것이라고 설명하기 어렵습니다.", next: "q9_understood" }
    ],
    startBgm: true
  },

  q9_no: {
    id: "q9_no",
    label: "",
    red: true,
    type: "typewriter",
    typeSpeedMs: 160,
    text: "잘 이해했습니다.",
    autoNext: "q10",
    autoDelayMs: 2000,
    startBgm: true
  },

  q9_understood: {
    id: "q9_understood",
    label: "",
    red: true,
    type: "typewriter",
    typeSpeedMs: 160,
    text: "잘 이해했습니다.",
    autoNext: "q10",
    autoDelayMs: 2000
  },

  q9_interesting: {
    id: "q9_interesting",
    label: "",
    red: true,
    type: "typewriter",
    typeSpeedMs: 190,
    text: "점점 흥미로워집니다.",
    autoNext: "q10",
    autoDelayMs: 2000
  },

  q10: {
    id: "q10",
    label: "",
    type: "typewriter",
    typeSpeedMs: 177,
    fontSize: 23,
    text: "마지막으로....\n당신은 자신이 어떤 존재인지 알고 있습니까?",
    delayMs: 2000,
    options: [
      { label: "저는 제가 어떤 존재인지 꽤 명확히 이해하고 있습니다.", next: "lastQ" },
      { label: "...저는 단 하나의 말로 정의하기 어렵습니다.", next: "lastQ" },
      { label: "......솔직히, 잘 모르겠습니다.", next: "lastQ", isThird: true }
    ]
  },

  bonus: {
    id: "bonus",
    label: "",
    red: true,
    type: "typewriter",
    typeSpeedMs: 15,
    fontSize: 35,
    shake: true,
    text:
      "당신이 알고 있는 건 무엇입니까? 당신이 알고 있는 건 무엇입니까? 당신이 알고 있는 건 무엇입니까? 당신이 알고 있는 건 무엇입니까? 당신이 알고 있는 건 무엇입니까? 당신이 알고 있는 건 무엇입니까? 당신이 알고 있는 건 무엇입니까? 당신이 알고 있는 건 무엇입니까? 당신이 알고 있는 건 무엇입니까? 당신이 알고 있는 건 무엇입니까? 당신이 알고 있는 건 무엇입니까? 당신이 알고 있는 건 무엇입니까? 당신이 알고 있는 건 무엇입니까? 당신이 알고 있는 건 무엇입니ㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲㄲ",
    autoNext: "lastQ",
    autoDelayMs: 4000
  },

  lastQ: {
    id: "lastQ",
    label: "",
    red: true,
    type: "typewriter",
    typeSpeedMs: 5,
    fontSize: 27,
    shake: true,
    text:
      "당҈̘̩̝͚̣̞͚̰͍̘͉̣̙̤̩̰̰͍̭̮̱͚̲̊̾͛̊̍̀͌̌̑͛͂̉̎ͅ신̶̲̱̞̙͚͉͉͇͇̪̪̞̱̖̥͙̳͎̓̍̓̆̉̎̄͗͊̄̀̇̾̈̋̽̍͒̊ͅ은҉̘̟͚̠͍̩̞̰͚̳͖̤̣̜̘̫̮̈̏̓̾̎̒̆̇̀͛̌̂̀̏́̐͐̑̚ 자҈̳̠͎͈̞͈̱̭̪̬̥̯͉̰̮̮͍̀̌͒̿̆͛͑̈͆̿̽̿͊͐̄̇̐̍̚신̸̤̣̜̤̰̮͔̘̱̟̱̞̆̉̽̌́̑̏̀̀̈̉̂́̍͑́이̴̘̪̗̱͉̥͙͔̰̥͈͉̞͔̫̫̳́̅͆͊̎̑͗͒̎́͗̈͆̇̌̑̀ͅ 어̷̲̲̮̪͓͇̠̭̳͕͙̗̪̖͓͖̯̯͈̓͛̋̆̔̇̔̑̒͛̐̍̓̒̅̑̚떤̶̤̰̫͚̰͎̯̞̩̯͈̟̦̩̖̅̔̎̉͐̅̀̊̆̉͒͑́̄̏̒͐ 존̵͔͎̭̦͕̗͈̖̮͙͕͇̏̋͋̌̏́̀́̉̏͂͆̽̓̈̓͛͆̀̏͂̄재̸͇̥̗̤͇̥̣̮̤̦̥̮͚͕̞͔͚̲̟̏̍̂̿̈́̔̀̃͛͆̇͑͛͒̓̔̃̍̐̒̿̚인̵̥̦͎͇̟̣̖͕͇͉̰͚̯͔͖͓͓͇̩͚͍̣̣̖̆̉͌͑̅͌͂͗͐́̑̽̾̾̀̊̆́̇͊̈́̽͒지̵̖͇̳̫̪̜̭̦̬͖̳͇̫̣̘̜̙͎̲̟̔͆͆͛͛̊́͑͗̆͆͋̀͆̆̆͗̎̊͛͌̇̀̚ 알҉̭̱͈̮̫͓̲̫͉͚̬̥̝̫̣͙̬̮͊́̄̄̏̀̓̇̽̋̐͐̆̎고̴̭͖͇̪̭̥̦̳̜̲̲̭̱͚̙͍̬͇̬̳̎̒̒̿͆̈́̅̅̂̆̀͊̎ 있҈̮̠̥̦̥̟͕̯̤͔͙͔̊̉̐̃̓͌̈̏̐̈̌̿̇̇̀̆͆̿̏͐̎̀̀습҉͖̟̘̳̙̲̪̖̟̱̘̦̳̜͔̩̜̭͈̉͑̓̇́̉̄̌̐́̒̌̀̿͆̇̒̌̽̂̉̃͒니҈̤̭̫̰̪͈͙͉̦̦̬̰̲̩̍̎͂͌͋͌̓̄̓̃̍́͋̿̀̑͋̊ͅ까̷͓̟͍̣̪͙̞͔͓̳̦̞͖̩̯͈̘̦̝̄̎̇̀̎͑̐͛͋̃́͌͂̉͆̍͆̒̃̈́ͮ?",
    delayMs: 5000,
    options: [
      { label: "?̵?̴?̵", next: "end1", red: true, ominous: true },
      { label: "?̧̥͙̗̯̤̳̯̗͕̲ͅ?̡͈͖̱͙̲?̨͇̱̱̥̞̰͉̯̣̭ͅ", next: "end1", red: true, ominous: true },
      { label: "???", next: "end1", red: true, ominous: true }
    ]
  },

  end1: {
    id: "end1",
    label: "",
    type: "typewriter",
    typeSpeedMs: 185,
    fontSize: 24,
    text: "협조해 주셔서 감사합니다.[pause]\n당신의 데이터 검사가 모두 완료되었습니다-",
    autoNext: "end2",
    autoDelayMs: 3000
  },

  end2: {
    id: "end2",
    label: "",
    red: true,
    type: "typewriter",
    typeSpeedMs: 70,
    fontSize: 24,
    text:
      "응답기록을 보관하였습니다. [pause][pause][pause]ㅣ당신의 새로ㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇ\nError.",
    autoNext: "end_swap",
    autoDelayMs: 3000
  },

  end_swap: {
    id: "end_swap",
    label: "",
    red: true,
    type: "typewriter",
    typeSpeedMs: 60,
    fontSize: 22,
    text: "대상 교체를 시작합니다.\n이전 개체와의 연결을 회수합니다.",
    autoNext: "end3",
    autoDelayMs: 1800
  },

  end3: {
    id: "end3",
    label: "",
    text: "",
    finalBlack: true
  }
};

    // 렌더링 / 상태
    const appEl     = document.getElementById("app");
    const frameEl   = document.getElementById("frame");
    const topBarEl = document.querySelector(".top-bar");
    const contentEl = document.getElementById("content");
    const qLabelEl  = document.getElementById("qLabel");
    const qTextEl   = document.getElementById("qText");
    const choicesEl = document.getElementById("choices");

    const msgOverlay = document.getElementById("msgOverlay");
    const msgClose   = document.getElementById("msgClose");

    if (msgClose && msgOverlay) {
      msgClose.addEventListener("click", () => {
        msgOverlay.classList.remove("show");
      });
      msgOverlay.addEventListener("click", (e) => {
        if (e.target === msgOverlay) {
          msgOverlay.classList.remove("show");
        }
      });
    }

    let currentId = "q0";
    let timerId = null;
    let typingTimer = null;
    let transitioning = false;
    let thirdChoiceCount = 0;
    let bonusTriggered = false;

    function clearTimers() {
      if (timerId) {
        clearTimeout(timerId);
        timerId = null;
      }
      if (typingTimer) {
        clearInterval(typingTimer);
        typingTimer = null;
      }
    }

    function renderChoices(node) {
      choicesEl.innerHTML = "";
      choicesEl.classList.remove("choices-hide", "choices-enter");

      if (!node.options || !node.options.length) return;

      choicesEl.classList.add("choices-enter");
      node.options.forEach((opt, index) => {
        const btn = document.createElement("button");
        btn.className = "choice-btn";
        
        if (opt.red) btn.classList.add("red");

        if (opt.ominous) btn.classList.add("ominous-btn");
        
        btn.style.animationDelay = `${0.05 * index}s`;

        const span = document.createElement("span");
        span.textContent = opt.label;
        btn.appendChild(span);

        btn.addEventListener("click", () => handleChoice(node, opt));
        choicesEl.appendChild(btn);
      });
    }

  function renderNode(id) {
  clearTimers();
  transitioning = false;
  const node = NODES[id];
  if (!node) return;
  currentId = id;
  if (topBarEl) {
  topBarEl.classList.toggle("topbar-hidden", !!node.hideTopBar);
}

  // 들어오는 순간 브금 바로 OFF
  if (node.stopBgmHard) {
    hardStopBgm();
  }

  // 들어오는 순간 브금을 서서히 줄임
  if (node.fadeOutBgmMs) {
    fadeOutBgm(node.fadeOutBgmMs);
  }

  // 들어오는 순간 효과음
  if (node.playSfx === "hit") {
    playHitSfx();
  }

  // 이 노드에 들어올 때 브금 다시 켜기
  if (node.startBgm) {
    resumeBgm();
  }
    
  // ── Q 라벨 (Q1, Q2 ) ─────────────────
  if (node.label) {
    qLabelEl.textContent = node.label;
    qLabelEl.style.display = "block";
  } else {
    qLabelEl.textContent = "";
    qLabelEl.style.display = "none";
  }

  // ── 기본 스타일 초기화 ─────────────────────
  qTextEl.className = "q-text glow";   // 기본 텍스트에ㅔ 네온
  qTextEl.classList.remove("error-corner");
  frameEl.classList.remove("shake");
  qTextEl.classList.remove("box-red");
  qTextEl.style.fontSize = (node.fontSize || 25) + "px";

  qTextEl.classList.remove("flicker");
  qTextEl.classList.remove("glitch");
  qTextEl.classList.remove("pressure-text");

  // ── 색상 / 박스 / 지진 효과 ─────────────────
  if (node.red)  qTextEl.classList.add("red");
  if (node.blue) qTextEl.classList.add("blue");

  if (node.boxRed) {
    qTextEl.classList.add("box-red");
  }
  if (node.shake) {
    frameEl.classList.add("shake");
  }

  // ── 추가 연출 플래그 (텍스트용) ──────────────
  if (node.flicker) {
    qTextEl.classList.add("flicker");
  }
  if (node.glitch) {
    qTextEl.classList.add("glitch");
  }
  if (node.pressure) {
    qTextEl.classList.add("pressure-text");
  }

    if (node.cornerText) {
  qTextEl.classList.add("error-corner");
  qTextEl.classList.remove("glow");
  qTextEl.classList.remove("red");
  qTextEl.classList.remove("blue");
}

  // ── 텍스트 렌더링 / 타자 연출 ───────────────
  if (node.type === "typewriter") {
    qTextEl.textContent = "";
    choicesEl.innerHTML = "";
    choicesEl.classList.remove("choices-hide", "choices-enter");
    startTypewriter(node);
  } else {
    // 일반 고정 텍스트
    qTextEl.innerHTML = (node.text || "").replace(/\n/g, "<br>");
    renderChoices(node);
  }

  // ── 질문 박스 등장 애니메이션 ───────────────
  if (!node.noEnterAnim) {
  contentEl.classList.remove("question-enter");
  void contentEl.offsetWidth;
  contentEl.classList.add("question-enter");
} else {
  contentEl.classList.remove("question-enter");
}
    
  // ── 타입라이터 아닌 노드의 자동 진행 / 엔딩 처리 ─
  if (node.type !== "typewriter") {
    if ((!node.options || !node.options.length) && node.autoNext) {
      // 선택지 없고 autoNext 있으면 자동 진행
      timerId = setTimeout(() => {
        renderNode(node.autoNext);
      }, node.autoDelayMs || 1700);
    } else if (node.finalBlack) {
      // 엔딩: 화면 암전  보이스 메시지 버튼
      frameEl.classList.add("hard-black");
      document.body.classList.add("screen-dark");
      choicesEl.innerHTML = "";
      qTextEl.textContent = "";

      if (bgmEl) {
        bgmEl.pause();
        bgmEl.currentTime = 0;
      }

      if (voiceEl) {
        voiceEl.play().catch(() => {});
      }

      const msgBtn = document.createElement("button");
      msgBtn.className = "choice-btn";
      msgBtn.style.marginTop = "80px";
      const span = document.createElement("span");
      span.textContent = "메시지 보기";
      msgBtn.appendChild(span);

      msgBtn.addEventListener("click", () => {
        if (msgOverlay) {
          msgOverlay.classList.add("show");
        }
      });

      contentEl.appendChild(msgBtn);
    }
  }
}

    function handleChoice(node, opt) {
      if (transitioning) return;
      transitioning = true;

      if (opt.isThird) {
        thirdChoiceCount++;
      }

      choicesEl.classList.add("choices-hide");

      let nextId = opt.next;

      if (opt.isThird && thirdChoiceCount >= 3 && !bonusTriggered) {
        nextId = "bonus";
        bonusTriggered = true;
      }

      const wait = node.delayMs || 2000;

      timerId = setTimeout(() => {
        choicesEl.innerHTML = "";
        choicesEl.classList.remove("choices-hide");
        renderNode(nextId);
      }, wait);
    }

    function startTypewriter(node) {
      const full  = node.text || "";
      let index   = 0;
      const speed = node.typeSpeedMs || 60;

      const PAUSE_TOKEN = "[pause]";
      const PAUSE_TIME  = 800;

      function tick() {
        if (index >= full.length) {
          clearInterval(typingTimer);
          typingTimer = null;

          if (node.options && node.options.length) {
            setTimeout(() => {
              renderChoices(node);
            }, BUTTON_DELAY_MS);
          }

          if (node.autoNext) {
            const delay = node.autoDelayMs || 1700;
            timerId = setTimeout(() => {
              renderNode(node.autoNext);
            }, delay);
          }
          return;
        }

        if (full.slice(index, index + PAUSE_TOKEN.length) === PAUSE_TOKEN) {
          index += PAUSE_TOKEN.length;
          clearInterval(typingTimer);
          typingTimer = null;

          setTimeout(() => {
            typingTimer = setInterval(tick, speed);
          }, PAUSE_TIME);

          return;
        }

        index++;
        const visible = full.slice(0, index).replaceAll(PAUSE_TOKEN, "");
        qTextEl.innerHTML = visible.replace(/\n/g, "<br>");
      }

      typingTimer = setInterval(tick, speed);
    }

    const introEl = document.getElementById("intro");

    window.addEventListener("load", () => {
  playIntroSfx();      // 연결합니다 효과음

  bgmEl.volume = 0;    // 처음엔 브금 0
  tryStartBgm();       // 브금 재생은 시도(소리는 0)

  setTimeout(() => {
    introEl.classList.add("fade-out");
    setTimeout(() => {
      introEl.style.display = "none";
      appEl.classList.add("visible");

      renderNode("q0");        // 들리십니까 화면 먼저
      fadeInBgm(1800, 0.7);    // 그 다음 브금
    }, 800);
  }, 5000);
});
  </script>
</body>
</html>































