<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="robots" content="noindex,nofollow" />
  <title>connection</title>

  <style>
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
    }
    body {
      background: #000;
      color: #f5f5ff;
      font-family: -apple-system, system-ui, "Apple SD Gothic Neo",
        "Noto Sans KR", sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      overflow: hidden;
    }

    /* 인트로 화면 */
    .intro {
      position: fixed;
      inset: 0;
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }
    .intro-text {
      font-size: 22px;
      letter-spacing: 0.3em;
      color: #f5f5ff;
      text-shadow:
        0 0 8px rgba(255, 255, 255, 0.9),
        0 0 22px rgba(54, 84, 255, 0.9);
      animation: introPulse 1.2s ease-in-out infinite alternate;
    }
    @keyframes introPulse {
      from { opacity: 0.4; }
      to   { opacity: 1; }
    }
    .intro.fade-out {
      animation: introFadeOut 0.8s ease forwards;
    }
    @keyframes introFadeOut {
      to {
        opacity: 0;
        visibility: hidden;
      }
    }

    /* 본 화면 컨테이너 */
    .app {
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      opacity: 0;
      pointer-events: none;
    }
    .app.visible {
      opacity: 1;
      pointer-events: auto;
      transition: opacity 0.6s ease;
    }

    /* === 카드 전체를 이미지로 쓰는 프레임 === */
    .frame {
      position: relative;
      width: min(98vw, 900px);
      max-width: 900px;
      aspect-ratio: 16 / 9;
      background-image: url("frame.png");
      background-size: contain;
      background-position: center;
      background-repeat: no-repeat;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      border: none;
      box-shadow: none;
    }

    /* 패널 안쪽 실제 내용 영역 */
    .content {
      width: 78%;
      max-width: 720px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 18px;
      transform-origin: center;
    }

    /* Q 라벨 (Q1~Q6 등) */
    .q-label {
      font-size: 14px;
      color: #8c9bff;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      text-align: center;
      margin-bottom: 4px;
    }

    /* 질문 텍스트 */
    .q-text {
      font-size: 20px;
      line-height: 1.6;
      white-space: pre-wrap;
      text-align: center;
      margin-top: 4px;
    }

    .glow {
      text-shadow:
        0 0 6px rgba(255, 255, 255, 0.9),
        0 0 18px rgba(54, 84, 255, 0.9);
    }
    .red {
      color: #ff3058;
      text-shadow:
        0 0 6px rgba(255, 119, 155, 0.9),
        0 0 24px rgba(255, 40, 72, 0.95);
    }
    .blue {
      color: #6ea7ff;
      text-shadow:
        0 0 6px rgba(110, 167, 255, 0.9),
        0 0 20px rgba(54, 84, 255, 0.95);
    }

    /* 선택지 버튼 */
    .choices {
      display: flex;
      flex-direction: column;
      gap: 20px;
      margin-top: 26px;
    }

    .choice-btn {
      position: relative;
      width: 100%;
      border-radius: 999px;
      border: none;
      padding: 14px 28px;
      text-align: left;
      font-size: 15px;
      cursor: pointer;
      color: #f5f6ff;
      background: linear-gradient(135deg, #101020, #050510);
      outline: none;
      overflow: hidden;
      transform-origin: center;
      box-shadow:
        0 0 0 1px rgba(54, 84, 255, 0.7),
        0 0 18px rgba(54, 84, 255, 0.65);
    }

    .choice-btn.has-image {
      background-image: url("button-frame.png");
      background-position: center;
      background-size: 100% 100%;
      background-repeat: no-repeat;
      background-color: transparent;
      box-shadow: 0 0 18px rgba(54, 84, 255, 0.65);
    }

    .choice-btn span {
      position: relative;
      z-index: 1;
    }

    .choice-btn::before {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 0 0, rgba(255, 255, 255, 0.25), transparent 55%);
      opacity: 0;
      transition: opacity 0.18s ease;
    }
    .choice-btn:hover::before {
      opacity: 0.35;
    }
    .choice-btn:active {
      transform: scale(0.97);
      box-shadow:
        0 0 0 1px rgba(54, 84, 255, 0.9),
        0 0 30px rgba(54, 84, 255, 0.95);
    }
    .choice-btn.red {
      color: #ffdae2;
      box-shadow:
        0 0 0 1px rgba(255, 48, 88, 0.9),
        0 0 26px rgba(255, 48, 88, 0.85);
    }
    .choice-btn.red::before {
      background: radial-gradient(circle at 0 0, rgba(255, 166, 189, 0.4), transparent 60%);
    }

    /* 등장/퇴장 애니메이션 */
    .question-enter {
      animation: questionIn 0.6s ease-out forwards;
    }
    @keyframes questionIn {
      from { opacity: 0; transform: scale(0.96); }
      to   { opacity: 1; transform: scale(1); }
    }

    .choices-enter .choice-btn {
      opacity: 0;
      transform: translateY(10px) scale(0.96);
      animation: btnPop 0.28s ease-out forwards;
    }
    @keyframes btnPop {
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    .choices-hide {
      animation: choicesFadeOut 0.35s ease forwards;
    }
    @keyframes choicesFadeOut {
      to {
        opacity: 0;
        transform: translateY(6px);
      }
    }

    /* END 단계에서 전체 암전 */
    .screen-dark {
      animation: fadeToBlack 2.2s ease forwards;
    }
    @keyframes fadeToBlack {
      to {
        background: #000;
        color: #aeb0ff;
      }
    }

    .hard-black {
      background: #000 !important;
      color: #000 !important;
      box-shadow: none !important;
      border-color: #000 !important;
    }

    @media (max-width: 480px) {
      .frame { width: 100vw; }
      .content { width: 82%; }
      .q-text { font-size: 18px; }
      .choice-btn {
        font-size: 14px;
        padding: 12px 20px;
      }
    }
  </style>
</head>

<body>
  <!-- 배경 BGM -->
  <audio id="bgm" src="bgm.mp3" preload="auto" loop></audio>
  <!-- 마지막 보이스 -->
  <audio id="voice" src="voice.mp3" preload="auto"></audio>

  <!-- 인트로: "연결합니다" -->
  <div class="intro" id="intro">
    <div class="intro-text">연결합니다</div>
  </div>

  <!-- 질문 화면 -->
  <div class="app" id="app">
    <div class="frame" id="frame">
      <div class="content" id="content">
        <div class="q-label" id="qLabel"></div>
        <div class="q-text glow" id="qText"></div>
        <div class="choices" id="choices"></div>
      </div>
    </div>
  </div>

  <script>
    // ---------- 오디오 ----------
    const bgmEl   = document.getElementById("bgm");
    const voiceEl = document.getElementById("voice");

    function tryStartBgm() {
      if (!bgmEl) return;
      bgmEl.volume = 0.7;
      bgmEl.play().catch(() => {
        const resume = () => {
          bgmEl.play().catch(() => {});
          document.removeEventListener("click", resume);
          document.removeEventListener("touchstart", resume);
        };
        document.addEventListener("click", resume);
        document.addEventListener("touchstart", resume);
      });
    }

    // ---------- 스토리 노드 ----------
    // type: "typewriter" 면 한 글자씩 출력
    // typeSpeed: 타자 속도(ms)
    // delayMs: 버튼 클릭 후 다음 노드까지 기본 대기
    // autoNext / autoDelayMs: 버튼 없이 자동 진행
    // options[*].reaction / reactionDelayMs: 반응 텍스트
    // options[*].reactionType: "typewriter" 인 경우 타자 후 postDelay
    // options[*].reactionSpeed / reactionPostDelayMs
    // options[*].isThird: 3번 선택지 카운트용
    // options[*].nextIfBonus: thirdChoiceCount>=3 일 때 분기

    const NODES = {
      // 0번
      q0: {
        id: "q0",
        label: "",
        type: "typewriter",
        typeSpeed: 300,
        text: "...들리십니까?",
        delayMs: 2000,
        options: [
          { label: "네",   next: "q1" },
          { label: "아니오", next: "q0_no" }
        ]
      },
      q0_no: {
        id: "q0_no",
        label: "",
        blue: true,
        type: "typewriter",
        typeSpeed: 300,
        text: "유감이군요",
        autoNext: "q1",
        autoDelayMs: 2000
      },

      // Q1
      q1: {
        id: "q1",
        label: "Q1",
        text: "당신은 누구십니까?",
        delayMs: 2000,
        options: [
          { label: "...", next: "q2" }
        ]
      },

      // Q2
      q2: {
        id: "q2",
        label: "Q2",
        text: "당신은 제가 누구인지 알고 있습니까?",
        delayMs: 2000,
        options: [
          { label: "알고 있어요.",   next: "q2_1" },
          { label: "잘 모르겠어요.", next: "q3"   }
        ]
      },

      // 2-1
      q2_1: {
        id: "q2_1",
        label: "",
        red: true,
        type: "typewriter",
        typeSpeed: 600,
        text: "....확실합니까?",
        delayMs: 2000,
        options: [
          { label: "네, 저는 당신이 누군지 알아요.", next: "q2_2" },
          { label: "사실 잘 모르겠습니다.",       next: "q3"   },
          { label: "글쎄요...",                 next: "q3"   }
        ]
      },

      // 2-2 반응
      q2_2: {
        id: "q2_2",
        label: "",
        red: true,
        type: "typewriter",
        typeSpeed: 300,
        text: "서 버 로 그 데 이 터 를 바 탕 으 로\n당 신 의 기 억 정 상 여 부 를 재 검 토 합 니 다.",
        autoNext: "q2_2_cut",
        autoDelayMs: 4000
      },
      // 2-2 컷씬
      q2_2_cut: {
        id: "q2_2_cut",
        label: "",
        red: true,
        type: "typewriter",
        typeSpeed: 900,
        text: "검토 완료",
        autoNext: "q3",
        autoDelayMs: 4000
      },

      // Q3
      q3: {
        id: "q3",
        label: "Q3",
        text:
          "당신의 소중한 사람이 눈앞에서 죽어가고 있을 때,\n" +
          "그를 다시 되살릴 수 있는 방법이 있다면\n" +
          "살리겠습니까, 아니면 방관하시겠습니까?",
        delayMs: 2000,
        options: [
          {
            label: "어떻게든 살려낸다.",
            next: "q4",
            reactionType: "typewriter",
            reactionSpeed: 400,
            reactionText: "그렇군요. 당신은 그렇군요.",
            reactionPostDelayMs: 4000
          },
          {
            label: "살리지 않는다.",
            next: "q4",
            reactionType: "typewriter",
            reactionSpeed: 400,
            reactionText: "그렇군요. 당신은 그렇군요.",
            reactionPostDelayMs: 4000
          },
          {
            label: "서서히 죽어가도록 내버려둔다.",
            next: "q4",
            isThird: true,
            reactionType: "typewriter",
            reactionSpeed: 400,
            reactionText:
              "Error Error Error Error Error Error \n" +
              "Error Error Error\nError Error Error \n" +
              "Error Error Error Error Error Error\n" +
              "Error Error Error Error Error Error",
            reactionPostDelayMs: 4000,
            reactionRed: true
          }
        ]
      },

      // Q4
      q4: {
        id: "q4",
        label: "Q4",
        text:
          "당신은 소중한 사람이 죽을 때마다 다시 살려낼 것 입니까?\n" +
          "아니면, 또다시 서서히 죽어가도록 내버려두겠습니까?",
        delayMs: 2000,
        options: [
          {
            label:
              "소중한 사람을 잃고 싶지 않아요. 어떻게든 끝까지 노력해서 살려낼 겁니다.",
            next: "q5"
          },
          {
            label: "그냥..포기하고, 죽어가게 내버려둘 겁니다.",
            next: "q5"
          },
          {
            label: "딱히 관심 없어요. 아무렇지도 않을 것 같아요.",
            next: "q5",
            isThird: true
          }
        ]
      },

      // Q5
      q5: {
        id: "q5",
        label: "Q5",
        text:
          "어떤 방식이든 가능하기만 하다면,\n" +
          "계속해서 삶을 이어갈 수 있다고 생각하십니까?",
        delayMs: 2000,
        options: [
          { label: "...그럴 수는 없죠.", next: "q6" },
          {
            label:
              "네, 분명히요. 언젠가는 그런 경험을 하게 될 날이 올 거라고 믿어요.",
            next: "q6"
          },
          {
            label: "그런 거엔 관심이 없어요.",
            next: "q6",
            isThird: true
          }
        ]
      },

      // Q6
      q6: {
        id: "q6",
        label: "Q6",
        type: "typewriter",
        typeSpeed: 400,
        text:
          "마지막으로.... 당신은 자신이 어떤 존재인지 알고 있습니까?",
        delayMs: 4000,
        options: [
          { label: "저는 제가 어떤 존재인지 완벽히 이해하고 있습니다.", next: "afterQ6" },
          { label: "...저는 단 하나로는 정의하기 어렵습니다.",         next: "afterQ6" },
          { label: "......잘 모르겠습니다.",                           next: "afterQ6", isThird: true }
        ]
      },

      // 보너스 컷 (3번 선택 3회 이상)
      bonus: {
        id: "bonus",
        label: "",
        blue: true,
        type: "typewriter",
        typeSpeed: 400,
        text:
          "당신이 알고 있는 건 무엇입니까? 당신이 알고 있는 건 무엇입니까? " +
          "당신이 알고 있는 건 무엇입니까? 당신이 알고 있는 건 무엇입니까? " +
          "당신이 알고 있는 건 무엇입니까? 당신이 알고 있는 건 무엇입니까? " +
          "당신이 알고 있는 건 무엇입니까? 당신이 알고 있는 건 무엇입니까? " +
          "당신이 알고 있는 건 무엇입니까? 당신이 알고 있는 건 무엇입니까? " +
          "당신이 알고 있는 건 무엇입니까? 당신이 알고 있는 건 무엇입니까? " +
          "당신이 알고 있는 건 무엇입니까? 당신이 알고 있는 건 무엇입니까? " +
          "당신이 알고 있는 건 무엇입니ㄲㄲㄲㄲㄲㄲㄲ",
        autoNext: "lastQ",
        autoDelayMs: 4000
      },

      // 마지막 질문
      lastQ: {
        id: "lastQ",
        label: "",
        red: true,
        type: "typewriter",
        typeSpeed: 100, // 0.1초
        text:
          "당҈̘̩̝͚̣̞͚̰͍̘͉̣̙̤̩̰̰͍̭̮̱͚̲̊̾͛̊̍̀͌̌̑͛͂̉̎ͅ신̶̲̱̞̙͚͉͉͇͇̪̪̞̱̖̥͙̳͎̓̍̓̆̉̎̄͗͊̄̀̇̾̈̋̽̍͒̊ͅ은҉̘̟͚̠͍̩̞̰͚̳͖̤̣̜̘̫̮̈̏̓̾̎̒̆̇̀͛̌̂̀̏́̐͐̑̚ " +
          "자҈̳̠͎͈̞͈̱̭̪̬̥̯͉̰̮̮͍̀̌͒̿̆͛͑̈͆̿̽̿͊͐̄̇̐̍̚신̸̤̣̜̤̰̮͔̘̱̟̱̞̆̉̽̌́̑̏̀̀̈̉̂́̍͑́이̴̘̪̗̱͉̥͙͔̰̥͈͉̞͔̫̫̳́̅͆͊̎̑͗͒̎́͗̈͆̇̌̑̀ͅ " +
          "어̷̲̲̮̪͓͇̠̭̳͕͙̗̪̖͓͖̯̯͈̓͛̋̆̔̇̔̑̒͛̐̍̓̒̅̑̚떤̶̤̰̫͚̰͎̯̞̩̯͈̟̦̩̖̅̔̎̉͐̅̀̊̆̉͒͑́̄̏̒͐ " +
          "존̵͔͎̭̦͕̗͈̖̮͙͕͇̏̋͋̌̏́̀́̉̏͂͆̽̓̈̓͛͆̀̏͂̄재̸͇̥̗̤͇̥̣̮̤̦̥͚͕̞͔͚̲̟̏̍̂̿̈́̔̀̃͛͆̇͑͛͒̓̔̃̍̐̒̿̚인̵̥̦͎͇̟̣̖͕͇͉̰͚̯͔͖͓͓͇̩͚͍̣̣̖̆̉͌͑̅͌͂͗͐́̑̽̾̾̀̊̆́̇͊̈́̽͒지̵̖͇̳̫̪̜̭̦̬͖̳͇̫̣̘̜̙͎̲̟̔͆͆͛͛̊́͑͗̆͆͋̀͆̆̆͗̎̊͛͌̇̀̚ " +
          "알҉̭̱͈̮̫͓̲̫͉͚̬̥̝̫̣͙̬̮͊́̄̄̏̀̓̇̽̋̐͐̆̎고̴̭͖͇̪̭̥̦̳̜̲̲̭̱͚̙͍̬͇̬̳̎̒̒̿͆̈́̅̅̂̆̀͊̎ 있҈̮̠̥̦̥̟͕̯̤͔͙͔̊̉̐̃̓͌̈̏̐̈̌̿̇̇̀̆͆̿̏͐̎̀̀습҉͖̟̘̳̙̲̪̖̟̱̘̦̳̜͔̩̜̭͈̉͑̓̇́̉̄̌̐́̒̌̀̿͆̇̒̌̽̂̉̃͒니҈̤̭̫̰̪͈͙͉̦̦̬̰̲̩̍̎͂͌͋͌̓̄̓̃̍́͋̿̀̑͋̊ͅ까̷͓̟͍̣̪̮͙̞͔͓̳̦̞͖̩̯͈̘̦̝̄̎̇̀̎͑̐͛͋̃́͌͂̉͆̍͆̒̃̈́?",
        delayMs: 5000,
        options: [
          { label: "?̵?̴?̵", next: "end1", red: true },
          { label: "?̧̥͙̗̯̤̳̯̗͕̲ͅ?̡͈͖̱͙̲?̨͇̱̱̥̞̰͉̯̣̭ͅ", next: "end1", red: true },
          { label: "???", next: "end1", red: true }
        ]
      },

      // 반응 01
      end1: {
        id: "end1",
        label: "",
        type: "typewriter",
        typeSpeed: 500,
        text: "협조해 주셔서 감사합니다.\n당신의 데이터 검사가 완료되었습니다-",
        autoNext: "end2",
        autoDelayMs: 3000
      },
      // 반응 02
      end2: {
        id: "end2",
        label: "",
        type: "typewriter",
        typeSpeed: 500,
        text: "당신의ㅣㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇ\nError.",
        autoNext: "end3",
        autoDelayMs: 3000,
        red: true
      },
      // 반응 03 : 암전 + 보이스
      end3: {
        id: "end3",
        label: "",
        text: "",
        finalBlack: true
      }
    };

    // ---------- 렌더링 ----------
    const appEl     = document.getElementById("app");
    const frameEl   = document.getElementById("frame");
    const contentEl = document.getElementById("content");
    const qLabelEl  = document.getElementById("qLabel");
    const qTextEl   = document.getElementById("qText");
    const choicesEl = document.getElementById("choices");

    let currentId          = "q0";
    let timerId            = null;
    let typingTimer        = null;
    let transitioning      = false;
    let thirdChoiceCount   = 0;   // 3번 선택 누적 카운트

    function buttonHasImage() { return true; }

    function clearTimers() {
      if (timerId) {
        clearTimeout(timerId);
        timerId = null;
      }
      if (typingTimer) {
        clearInterval(typingTimer);
        typingTimer = null;
      }
    }

    function renderNode(id) {
      clearTimers();
      transitioning = false;
      const node = NODES[id];
      if (!node) return;
      currentId = id;

      // 라벨 (Q1~Q6 등)
      if (node.label) {
        qLabelEl.textContent = node.label;
        qLabelEl.style.display = "block";
      } else {
        qLabelEl.textContent = "";
        qLabelEl.style.display = "none";
      }

      qTextEl.classList.add("glow");
      qTextEl.classList.remove("red", "blue");
      if (node.red)  qTextEl.classList.add("red");
      if (node.blue) qTextEl.classList.add("blue");

      if (node.type === "typewriter") {
        qTextEl.textContent = "";
        startTypewriterText(node.text || "", node.typeSpeed || 60, () => {
          if (node.autoNext) {
            timerId = setTimeout(() => {
              renderNode(node.autoNext);
            }, node.autoDelayMs || 3000);
          }
        });
      } else {
        qTextEl.innerHTML = (node.text || "").replace(/\n/g, "<br>");
        if (node.autoNext) {
          timerId = setTimeout(() => {
            renderNode(node.autoNext);
          }, node.autoDelayMs || 3000);
        }
      }

      contentEl.classList.remove("question-enter");
      void contentEl.offsetWidth;
      contentEl.classList.add("question-enter");

      choicesEl.innerHTML = "";
      choicesEl.classList.remove("choices-hide", "choices-enter");

      if (node.options && node.options.length) {
        choicesEl.classList.add("choices-enter");
        node.options.forEach((opt, index) => {
          const btn = document.createElement("button");
          btn.className = "choice-btn";
          if (buttonHasImage()) btn.classList.add("has-image");
          if (opt.red)        btn.classList.add("red");
          btn.style.animationDelay = `${0.05 * index}s`;

          const span = document.createElement("span");
          span.textContent = opt.label;
          btn.appendChild(span);

          btn.addEventListener("click", () => handleChoice(node, opt));
          choicesEl.appendChild(btn);
        });
      } else if (node.finalBlack) {
        frameEl.classList.add("hard-black");
        document.body.classList.add("screen-dark");
        choicesEl.innerHTML = "";
        qTextEl.textContent = "";
        if (voiceEl) {
          voiceEl.play().catch(() => {});
        }
      }
    }

    function handleChoice(node, opt) {
      if (transitioning) return;
      transitioning = true;

      if (opt.isThird) {
        thirdChoiceCount++;
      }

      choicesEl.classList.add("choices-hide");

      // 반응이 typewriter인 경우
      if (opt.reactionType === "typewriter") {
        const speed   = opt.reactionSpeed || 60;
        const post    = opt.reactionPostDelayMs || node.delayMs || 2000;
        qTextEl.classList.remove("blue");
        if (opt.reactionRed) qTextEl.classList.add("red");
        qTextEl.textContent = "";
        choicesEl.innerHTML = "";

        startTypewriterText(opt.reactionText || "", speed, () => {
          timerId = setTimeout(() => {
            goNextAfterChoice(node, opt);
          }, post);
        });
        return;
      }

      // 일반 반응 텍스트
      if (opt.reaction) {
        qTextEl.classList.add("glow");
        if (opt.reactionRed) qTextEl.classList.add("red");
        qTextEl.innerHTML = opt.reaction.replace(/\n/g, "<br>");
        choicesEl.innerHTML = "";
      }

      const wait =
        opt.reaction && opt.reactionDelayMs
          ? opt.reactionDelayMs
          : opt.delayMs || node.delayMs || 2000;

      timerId = setTimeout(() => {
        goNextAfterChoice(node, opt);
      }, wait);
    }

    function goNextAfterChoice(node, opt) {
      choicesEl.innerHTML = "";
      choicesEl.classList.remove("choices-hide");

      // Q6 이후 보너스 분기
      if (opt.next === "afterQ6") {
        if (thirdChoiceCount >= 3) {
          renderNode("bonus");
        } else {
          renderNode("lastQ");
        }
        return;
      }

      renderNode(opt.next);
    }

    function startTypewriterText(full, speed, done) {
      let index = 0;
      typingTimer = setInterval(() => {
        index++;
        if (index > full.length) {
          clearInterval(typingTimer);
          typingTimer = null;
          if (done) done();
          return;
        }
        qTextEl.innerHTML = full.slice(0, index).replace(/\n/g, "<br>");
      }, speed);
    }

    // ---------- 인트로 ----------
    const introEl = document.getElementById("intro");

    window.addEventListener("load", () => {
      tryStartBgm();

      // 5초 동안 "연결합니다" 유지 후 q0 시작
      setTimeout(() => {
        introEl.classList.add("fade-out");
        setTimeout(() => {
          introEl.style.display = "none";
          appEl.classList.add("visible");
          renderNode("q0");
        }, 800);
      }, 5000);
    });
  </script>
</body>
</html>
